From d941266da5fb9c386128a180f39281ec9d4aa242 Mon Sep 17 00:00:00 2001
From: Lianbo Jiang <lijiang@redhat.com>
Date: Mon, 20 Feb 2023 15:57:04 +0800
Subject: [PATCH] gdb: Fix an assertion failure in the gdb's copy_type()

This is a backported patch from gdb. Without the patch, the following
crash command may abort due to an assertion failure in the gdb's
copy_type():

  crash> px __per_cpu_start:0
  gdbtypes.c:5505: internal-error: type* copy_type(const type*): Assertion `TYPE_OBJFILE_OWNED (type)' failed.
  A problem internal to GDB has been detected,
  further debugging may prove unreliable.
  Quit this debugging session? (y or n)

The gdb commit 8e2da1651879 ("Fix assertion failure in copy_type")
solved the current issue.

Reported-by: Buland Kumar Singh <bsingh@redhat.com>
Signed-off-by: Lianbo Jiang <lijiang@redhat.com>
---
 gdb-10.2.patch | 40 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/gdb-10.2.patch b/gdb-10.2.patch
index 91edfb338445..8c3b5a7fdf77 100644
--- a/gdb-10.2.patch
+++ b/gdb-10.2.patch
@@ -1737,3 +1737,43 @@ exit 0
          struct field *nextfield;
          short nfields;
          struct type *typedef_type, *target_type;
+--- gdb-10.2/gdb/gdbtypes.c.orig
++++ gdb-10.2/gdb/gdbtypes.c
+@@ -5492,27 +5492,25 @@ copy_type_recursive (struct objfile *objfile,
+ }
+ 
+ /* Make a copy of the given TYPE, except that the pointer & reference
+-   types are not preserved.
+-   
+-   This function assumes that the given type has an associated objfile.
+-   This objfile is used to allocate the new type.  */
++   types are not preserved. */
+ 
+ struct type *
+ copy_type (const struct type *type)
+ {
+-  struct type *new_type;
+-
+-  gdb_assert (TYPE_OBJFILE_OWNED (type));
++  struct type *new_type = alloc_type_copy (type);
+ 
+-  new_type = alloc_type_copy (type);
+   TYPE_INSTANCE_FLAGS (new_type) = TYPE_INSTANCE_FLAGS (type);
+   TYPE_LENGTH (new_type) = TYPE_LENGTH (type);
+   memcpy (TYPE_MAIN_TYPE (new_type), TYPE_MAIN_TYPE (type),
+ 	  sizeof (struct main_type));
+   if (type->main_type->dyn_prop_list != NULL)
+-    new_type->main_type->dyn_prop_list
+-      = copy_dynamic_prop_list (&TYPE_OBJFILE (type) -> objfile_obstack,
+-				type->main_type->dyn_prop_list);
++    {
++      struct obstack *storage = (TYPE_OBJFILE_OWNED (type)
++                                ? &TYPE_OBJFILE (type)->objfile_obstack
++                                : gdbarch_obstack (TYPE_OWNER (type).gdbarch));
++      new_type->main_type->dyn_prop_list
++       = copy_dynamic_prop_list (storage, type->main_type->dyn_prop_list);
++    }
+ 
+   return new_type;
+ }
+
-- 
2.37.1

