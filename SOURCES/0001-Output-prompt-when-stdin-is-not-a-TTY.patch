From 8527bbff71cbdfd90a67d5cec4a1d94156e6bf13 Mon Sep 17 00:00:00 2001
From: Hsin-Yi Wang <hsinyi@chromium.org>
Date: Wed, 31 May 2023 14:01:36 +0800
Subject: [PATCH 1/5] Output prompt when stdin is not a TTY

When stdin is not a TTY, prompt ("crash> ") won't be displayed. If
another process interact with crash with piped stdin/stdout, it will not
get the prompt as a delimiter.

Compared to other debugger like gdb, crash seems intended to give a
prompt in this case in the beginning of process_command_line(). It
checks if pc->flags does NOT have any of
READLINE|SILENT|CMDLINE_IFILE|RCHOME_IFILE|RCLOCAL_IFILE, a
prompt should be printed. The check will never be true since READLINE is
set in setup_environment() unconditionally.

It makes more sense to change the READLINE flag in the check to TTY
instead. Besides this change, the prompt in process_command_line() should
only be print when it's not in the middle of processing the input file
recovering from a previous FATAL command, because the prompt will be
displayed by the exec_input_file().

Additionally, when stdin is not TTY, repeat the command line from user
after prompt, which can give more context.

The prompt and command line can be opt out by using the silent (-s) flag.

Signed-off-by: Hsin-Yi Wang <hsinyi@chromium.org>
Signed-off-by: Lianbo Jiang <lijiang@redhat.com>
---
 cmdline.c | 14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/cmdline.c b/cmdline.c
index ded6551c2597..b7f919ae2279 100644
--- a/cmdline.c
+++ b/cmdline.c
@@ -64,8 +64,8 @@ process_command_line(void)
 	fp = stdout;
 	BZERO(pc->command_line, BUFSIZE);
 
-	if (!(pc->flags & 
-	    (READLINE|SILENT|CMDLINE_IFILE|RCHOME_IFILE|RCLOCAL_IFILE))) 
+	if (!pc->ifile_in_progress && !(pc->flags &
+	    (TTY|SILENT|CMDLINE_IFILE|RCHOME_IFILE|RCLOCAL_IFILE)))
 		fprintf(fp, "%s", pc->prompt);
 	fflush(fp);
 
@@ -136,12 +136,16 @@ process_command_line(void)
 			add_history(pc->command_line);
 		
 		check_special_handling(pc->command_line);
-        } else {
-        	if (fgets(pc->command_line, BUFSIZE-1, stdin) == NULL)
+	} else {
+		if (fgets(pc->command_line, BUFSIZE-1, stdin) == NULL)
 			clean_exit(1);
+		if (!(pc->flags & SILENT)) {
+			fprintf(fp, "%s", pc->command_line);
+			fflush(fp);
+		}
 		clean_line(pc->command_line);
 		strcpy(pc->orig_line, pc->command_line);
-        }
+	}
 
 	/*
 	 *  First clean out all linefeeds and leading/trailing spaces.
-- 
2.37.1

